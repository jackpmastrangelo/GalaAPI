package gala.gala_api.service;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;

import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.model.ObjectMetadata;
import com.amazonaws.services.s3.model.PutObjectRequest;
import com.amazonaws.services.s3.model.S3Object;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

/**
 * This service allows interaction with AWS S3 file storage.
 */
@Service
public class AwsS3Service {

  //TODO: Extract bucket as property if we use different buckets for different environments
  private static final String GALA_FILESTORE_BUCKET = "gala-internal-filestore";
  private static final String GALA_CDN_BUCKET = "gala-cdn";

  private static final String TICKET_EMAIL_KEY = "emails/sendEmailTemplate.html";

  //TODO: Extract key as property in some way if same bucket is used for different environments
  private static final String TICKET_QR_CODE_KEY_TEMPLATE = "prod/autogenerated/qr-codes/qr-%s.png";

  private static final String PNG_FILE_FORMAT = "PNG";
  private static final int QR_CODE_WIDTH = 200;
  private static final int QR_CODE_HEIGHT = 200;

  private AmazonS3 s3Client;

  /*
  //TODO If this seems reasonable delete this comment
    Reasons I think this should be in the AwsS3Service
    1. One less dependency of the ticket service
    2. No ambiguity in the ticket service about data sources
    3. The AwsS3Service would then fully convey the scope of S3 in Gala at the business level
    4. Consolidate S3-dependant constants like bucket names and keys
    5. Closer to the code that retrieves the QR-code and could clarify the lifecycle of the QR code
   */
  public void generateAndUploadQrCodeTicket(String ticketId) {
    QRCodeWriter qrCodeWriter = new QRCodeWriter();
    try {
      BitMatrix bitMatrix = qrCodeWriter.encode(ticketId, BarcodeFormat.QR_CODE, QR_CODE_WIDTH, QR_CODE_HEIGHT);

      ByteArrayOutputStream stream = new ByteArrayOutputStream();
      MatrixToImageWriter.writeToStream(bitMatrix, PNG_FILE_FORMAT, stream);
      byte[] qrCode = stream.toByteArray();

      uploadToS3Bucket(qrCode, GALA_CDN_BUCKET, String.format(TICKET_QR_CODE_KEY_TEMPLATE, ticketId));
    } catch (WriterException | IOException e) {
      throw new RuntimeException(e);
    }
  }

  //TODO Where is it best to handle filling in templates?
  public String fetchTicketEmailHtml(String eventName, String ticketId) {
    S3Object emailTemplate = s3Client.getObject(GALA_FILESTORE_BUCKET, TICKET_EMAIL_KEY);
    String htmlBody = readToString(emailTemplate);

    return htmlBody
            .replace("-EVENT_NAME-", eventName)
            //It is not apparent that this building the ticket key link without looking
            //at the template in S3
            .replace("-QR_CODE_NUMBER-", ticketId);
  }

  private void uploadToS3Bucket(byte[] s3Obj, String bucket, String key) {
    InputStream inputStream = new ByteArrayInputStream(s3Obj);

    PutObjectRequest request = new PutObjectRequest(bucket, key, inputStream, new ObjectMetadata());
    s3Client.putObject(request);
  }

  private String readToString(S3Object s3Object) {
    BufferedReader reader = new BufferedReader(new InputStreamReader(s3Object.getObjectContent()));

    StringBuilder result = new StringBuilder();
    String line;
    try {
      while ((line = reader.readLine()) != null) {
        result.append(line);
      }
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    return result.toString();
  }

  @Autowired
  public void setS3Client(AmazonS3 s3Client) {
    this.s3Client = s3Client;
  }
}