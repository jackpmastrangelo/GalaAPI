package gala.gala_api.service;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;

import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.model.ObjectMetadata;
import com.amazonaws.services.s3.model.PutObjectRequest;
import com.amazonaws.services.s3.model.S3Object;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

/**
 * This service allows interaction with AWS S3 file storage.
 */
@Service
public class AwsS3Service {

  //TODO: Extract bucket as property if we use different buckets for different environments
  private static final String GALA_FILESTORE_BUCKET = "gala-internal-filestore";
  private static final String GALA_CDN_BUCKET = "gala-cdn";

  private static final String TICKET_EMAIL_KEY = "emails/sendEmailTemplate.html";
  private static final String QR_CODE_DIRECTORY_KEY = "prod/autogenerated/qr-codes/";

  private static final String PNG_FILE_FORMAT = "PNG";
  private static final int QR_CODE_WIDTH = 200;
  private static final int QR_CODE_HEIGHT = 200;

  private AmazonS3 amazonS3Client;

  public void generateAndUploadQrCodeTicket(String ticketId) {
    QRCodeWriter qrCodeWriter = new QRCodeWriter();
    try {
      BitMatrix bitMatrix = qrCodeWriter.encode(ticketId, BarcodeFormat.QR_CODE, QR_CODE_WIDTH, QR_CODE_HEIGHT);

      ByteArrayOutputStream stream = new ByteArrayOutputStream();
      MatrixToImageWriter.writeToStream(bitMatrix, PNG_FILE_FORMAT, stream);
      byte[] qrCode = stream.toByteArray();

      uploadToS3Bucket(qrCode, GALA_CDN_BUCKET,  QR_CODE_DIRECTORY_KEY + "qr-" + ticketId + ".png");
    } catch (WriterException | IOException e) {
      throw new RuntimeException(e);
    }
  }

  //TODO Where is it best to handle filling in templates?
  // I feel like it should live as close as possible to template retrieval.
  // Is this too brittle?
  public String fetchTicketEmailHtml(String eventName, String ticketId) {
    S3Object emailTemplate = amazonS3Client.getObject(GALA_FILESTORE_BUCKET, TICKET_EMAIL_KEY);

    return readToString(emailTemplate)
            .replace("-EVENT_NAME-", eventName)
            .replace("-QR_CODE_NUMBER-", ticketId);
  }

  private void uploadToS3Bucket(byte[] s3Obj, String bucket, String key) {
    InputStream inputStream = new ByteArrayInputStream(s3Obj);

    PutObjectRequest request = new PutObjectRequest(bucket, key, inputStream, new ObjectMetadata());
    amazonS3Client.putObject(request);
  }

  private String readToString(S3Object s3Object) {
    BufferedReader reader = new BufferedReader(new InputStreamReader(s3Object.getObjectContent()));

    StringBuilder result = new StringBuilder();
    String line;
    try {
      while ((line = reader.readLine()) != null) {
        result.append(line);
      }
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    return result.toString();
  }

  @Autowired
  public void setAmazonS3Client(AmazonS3 amazonS3Client) {
    this.amazonS3Client = amazonS3Client;
  }
}